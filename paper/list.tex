\section{Specifying a Collaborative List}\label{sec:list}

An ordered list datatype (also known as \emph{sequence}) is the foundation of many collaborative applications.
For example, a text document can be expressed as an ordered list of characters, and an XML document is a tree in which the contents of each node is an ordered list of child nodes.

The basic operations on a list are the insertion and the deletion of individual list elements.
When several users concurrently modify a shared list object, an algorithm is required to merge these changes while ensuring that certain consistency properties are satisfied.
Algorithms to achieve this goal have been the topic of active research for approximately 30 years, under the headings of operational transformation \cite{Ellis:1989ue,Li:2004er,Nichols:1995fd,Oster:2006tr,Ressel:1996wx,Suleiman:1998eu,Sun:1998vf,Sun:1998un} and CRDTs \cite{Nedelec:2013ky,Nedelec:2016eo,Oster:2006wj,Preguica:2009fz,Roh:2011dw,Weiss:2010hx}.

However, throughout this time, the exact consistency properties provided by the algorithms have been somewhat unclear.
For example, Sun et al.~\cite{Sun:1998un} identified three desirable properties that they articulated informally: \emph{convergence}, \emph{causality preservation}, and \emph{intention preservation}.
While the definition of the first two properties is fairly unambiguous, the definition of ``intention preservation'' leaves much more room for interpretation.
Sun et al.\ define it as follows \cite{Sun:1998un}:
\begin{displayquote}
For any operation $O$, the effects of executing $O$ at all sites are the same as the intention of $O$, and the effect of executing $O$ does not change the effects of independent operations.
\end{displayquote}
where the term \emph{intention} is in turn defined as:
\begin{displayquote}
The intention of an operation $O$ is the execution effect which can be achieved by applying $O$ on the document state from which $O$ was generated.
\end{displayquote}
We now show how to define consistency properties for a list in a way that is simple and unambiguous, using the OpSets approach.

\subsection{Sequential Single-Element Insertion and Removal}

We specify the semantics of list element insertion and removal using the language of Isabelle/HOL, which is an ML-style functional programming language.
The definition is given in Figure~\ref{fig:isabelle-list-spec}.

\begin{figure}
\begin{isabelle}
\begin{tabbing}
~~~~{\isacharequal}\ \=InsertAfter\ \=\kill
\isacommand{datatype}\isamarkupfalse%
\ {\isacharprime}oid\ list{\isacharunderscore}op\\
~~~~{\isacharequal}\ \>InsertAfter\ \>{\isachardoublequoteopen}{\isacharprime}oid\ option{\isachardoublequoteclose}\\
~~~~~{\isacharbar}\ \>Remove\ \>{\isacharprime}oid
\end{tabbing}
\begin{tabbing}
~~~~{\isachardoublequoteopen}insert{\isacharunderscore}after\ oid\ {\isacharparenleft}\=Some\ ref{\isacharparenright}\ {\isacharparenleft}\=x{\isacharhash}xs{\isacharparenright}\ \={\isacharequal}\ oid\ {\isacharhash}\ list{\isachardoublequoteclose}\ \=\kill
\isacommand{fun}\isamarkupfalse%
\ insert{\isacharunderscore}after\ {\isacharcolon}{\isacharcolon}\ {\isachardoublequoteopen}{\isacharprime}oid\ {\isasymRightarrow}\ {\isacharprime}oid\ option\ {\isasymRightarrow}\ {\isacharprime}oid\ list\ {\isasymRightarrow}\ {\isacharprime}oid\ list{\isachardoublequoteclose}\ \isakeyword{where}\\
~~~~{\isachardoublequoteopen}insert{\isacharunderscore}after\ oid\>None\>list\>{\isacharequal}\ oid\ {\isacharhash}\ list{\isachardoublequoteclose}\>{\isacharbar}\\
~~~~{\isachardoublequoteopen}insert{\isacharunderscore}after\ oid\>{\isacharunderscore}\>{\isacharbrackleft}\ {\isacharbrackright}\>{\isacharequal}\ {\isacharbrackleft}\ {\isacharbrackright}{\isachardoublequoteclose}\>{\isacharbar}\\
~~~~{\isachardoublequoteopen}insert{\isacharunderscore}after\ oid\ {\isacharparenleft}\>Some\ ref{\isacharparenright}\ {\isacharparenleft}\>x{\isacharhash}xs{\isacharparenright}\ \>{\isacharequal}\ {\isacharparenleft}\\
~~~~~~~~~~~~~~if\ x\ {\isacharequal}\ ref\>then\ x\ {\isacharhash}\ oid\ {\isacharhash}\ xs\\
\>else\ x\ {\isacharhash}\ {\isacharparenleft}insert{\isacharunderscore}after\ oid\ {\isacharparenleft}Some\ ref{\isacharparenright}\ xs{\isacharparenright}{\isacharparenright}{\isachardoublequoteclose}
\end{tabbing}
\begin{tabbing}
~~~~{\isachardoublequoteopen}interp\ {\isacharparenleft}list{\isacharcomma}\ tomb{\isacharparenright}\ {\isacharparenleft}oid{\isacharcomma}\ InsertAfter\ \=ref{\isacharparenright}\ {\isacharequal}\ {\isacharparenleft}insert{\isacharunderscore}after\ oid\ ref\ list{\isacharcomma}\ \=tomb\ {\isasymunion}\ {\isacharbraceleft}ref{\isacharbraceright}\=\kill
\isacommand{fun}\isamarkupfalse%
\ interp\ {\isacharcolon}{\isacharcolon}\ {\isachardoublequoteopen}{\isacharprime}oid\ list\ {\isasymtimes}\ {\isacharprime}oid\ set\ {\isasymRightarrow}\ {\isacharparenleft}{\isacharprime}oid\ {\isasymtimes}\ {\isacharprime}oid\ list{\isacharunderscore}op{\isacharparenright}\ {\isasymRightarrow}\ {\isacharprime}oid\ list\ {\isasymtimes}\ {\isacharprime}oid\ set{\isachardoublequoteclose}\ \isakeyword{where}\\
~~~~{\isachardoublequoteopen}interp\ {\isacharparenleft}list{\isacharcomma}\ tomb{\isacharparenright}\ {\isacharparenleft}oid{\isacharcomma}\ InsertAfter\ \>ref{\isacharparenright}\ {\isacharequal}\ {\isacharparenleft}insert{\isacharunderscore}after\ oid\ ref\ list{\isacharcomma}\ \>tomb\>{\isacharparenright}{\isachardoublequoteclose}\ {\isacharbar}\\
~~~~{\isachardoublequoteopen}interp\ {\isacharparenleft}list{\isacharcomma}\ tomb{\isacharparenright}\ {\isacharparenleft}oid{\isacharcomma}\ Remove\ \>ref{\isacharparenright}\ {\isacharequal}\ {\isacharparenleft}list{\isacharcomma}\>tomb\ {\isasymunion}\ {\isacharbraceleft}ref{\isacharbraceright}\>{\isacharparenright}{\isachardoublequoteclose}
\end{tabbing}
\begin{tabbing}
\isacommand{definition}\isamarkupfalse%
\ interp{\isacharunderscore}list\ {\isacharcolon}{\isacharcolon}\ {\isachardoublequoteopen}{\isacharparenleft}{\isacharprime}oid\ {\isasymtimes}\ {\isacharprime}oid\ list{\isacharunderscore}op{\isacharparenright}\ list\ {\isasymRightarrow}\ {\isacharprime}oid\ list\ {\isasymtimes}\ {\isacharprime}oid\ set{\isachardoublequoteclose}\ \isakeyword{where}\\
~~~~{\isachardoublequoteopen}interp{\isacharunderscore}list\ ops\ {\isasymequiv}\ foldl\ interp\ {\isacharparenleft}{\isacharbrackleft}\ {\isacharbrackright}{\isacharcomma}\ {\isacharbraceleft}{\isacharbraceright}{\isacharparenright}\ ops{\isachardoublequoteclose}
\end{tabbing}
\end{isabelle}
\caption{Sequential specification of insertion and removal of list elements.}\label{fig:isabelle-list-spec}
\end{figure}

The definitions are polymorphic, using a type variable $\isa{{\isacharprime}oid}$ to denote the type of operation IDs.
As discussed in Section~\ref{sec:approach}, we assume that every operation has a unique operation ID (oid), which also serves to identify list elements: when a list element is inserted, the oid of the insertion operation is thereafter used to identify the list element inserted by that operation.

Each operation is a pair of $\isa{{\isacharprime}oid} \mathbin{\isasymtimes} \isa{{\isacharprime}oid\ list{\isacharunderscore}op}$, where the first part is the oid of the operation, and the second part is a tagged union type that can be either $\isa{InsertAfter}$ or $\isa{Remove}$.
$\isa{InsertAfter}$ takes an optional oid parameter: if provided, the new element is inserted after the existing list element with the given oid; if omitted ($\isa{None}$), the new element is inserted at the head of the list.
The $\isa{Remove}$ operation requires an oid parameter, which is the oid of the list element to remove.

TODO: discuss how to associate a value with each list element

The $\isa{interp}$ function shows how these operations are interpreted.
The interpretation is a pair of $\isa{{\isacharprime}oid\ list} \mathbin{\isasymtimes} \isa{{\isacharprime}oid\ set}$, where the first part is the list order obtained by interpreting all of the insertions, and the second part is the set of oids that have been removed (tombstones).
Insertion only adds to the list, and removal only adds to the tombstone set.

The $\isa{interp{\isacharunderscore}list}$ function takes a list of operations~-- which must be in order of ascending oid, as discussed in Section~\ref{sec:op-serial}~-- and applies $\isa{interp}$ in sequential order, starting with the initial state $\isa{{\isacharparenleft}{\isacharbrackleft}\ {\isacharbrackright}{\isacharcomma}\ {\isacharbraceleft}{\isacharbraceright}{\isacharparenright}}$.

The actual insertion is performed by the $\isa{insert{\isacharunderscore}after}$ function.
Its definition is perhaps the simplest possible: if $\isa{ref}$ is $\isa{None}$, then $\isa{oid}$ is placed at the head of the list; otherwise the function iterates over the list, searching for the reference element, and places the new element $\isa{oid}$ immediately after that element.
If the reference element does not appear in the list, the list is left unchanged.

\subsection{Specification versus Implementation}

The definition in Figure~\ref{fig:isabelle-list-spec} is almost trivially simple.
And yet, as we shall argue in the following sections, it is the most precise specification that has been given for a collaboratively editable list, and it subsumes prior specifications given in the literature.

Note that $\isa{interp{\isacharunderscore}list}$ is defined only for a list of operations that is sorted in order of ascending oid.
For any given set of operations, this sorted list is uniquely defined, and thus the interpretation is a deterministic function of the OpSet.
As discussed in Section~\ref{sec:approach}, this fact implies that the specification is convergent: as two nodes converge towards the same set of operations, their interpretation of the OpSet also converges.

However, in a system with several concurrently acting nodes, it is likely that the order in which nodes receive operations is not consistent with the oid order.
When a node receives an operation with a lower oid than an operation already applied, the $\isa{interp}$ function cannot be directly used to apply the operation to the interpreted node state, because $\isa{interp}$ is not commutative.
Instead, $\isa{interp{\isacharunderscore}list}$ must replay all operations in ascending order, incorporating the new operation at the appropriate point in the sorted list.
(Alternatively, a node could keep checkpoints of the interpreted state at selected older oids, jump back to the most recent checkpoint that precedes the oid of the incoming operation, and replay operations from that point onward.)

Viewed in this way, the specification of Figure~\ref{fig:isabelle-list-spec} is not an efficient implementation of a replicated datatype.
However, it is a simple, unambiguous, and executable specification of the operation semantics.
We can now produce more efficient implementations that allow operations to be processed out of order, and prove that their output is consistent with the specification.

\subsection{Preventing Interleaving}

An important property of the specification in Figure~\ref{fig:isabelle-list-spec} is that the interleaving anomaly of Figure~\ref{fig:bad-merge} is not allowed.
It is not immediately obvious why this is the case, but we prove this fact in Isabelle/HOL.

For an informal, intuitive argument why interleaving is ruled out, see Figure~\ref{fig:op-permutations}, which shows an editing scenario similar to Figure~\ref{fig:isabelle-list-spec}, but with the insertions of ``~Alice'' and ``~Charlie'' shortened to ``Al'' and ``Ch'' respectively.
The example contains four insertion operations (``A'', ``l'', ``C'', and ``h''), which can be ordered in six possible ways.
However, among the six possible operation orderings there are only two possible results: \texttt{ChAl} or \texttt{AlCh}.
Interleavings such as \texttt{CAhl} or \texttt{AChl} never occur.

In fact, the end result depends only on the relative ordering of the operations that insert ``A'' and ``C'', respectively.
All other operations can be reordered without affecting the outcome.
Thus, even if the inserted strings are longer than two characters, their relative ordering only depends on the oids of the first character of the strings.
The rest of the strings follow their initial character without interleaving.

Note that there are only six possible orderings of the four operations, and not $24 = 4!$, because (as discussed in Section~\ref{sec:op-serial}) we require that the ordering on identifiers is a linear extension of the causal order.
In this example we assume that text is typed from left to right (that is, ``A'' is always inserted before ``l'', and ``C'' is inserted before ``h'').
This implies that the oid of the operation inserting ``l'' must be greater than that of the insertion of ``A'', and likewise with ``h'' and ``C''.

\begin{figure}
% ``A'', ``l'', ``C'', ``h''
% ``A'', ``C'', ``l'', ``h''
% ``A'', ``C'', ``h'', ``l''
% ``C'', ``A'', ``l'', ``h''
% ``C'', ``A'', ``h'', ``l''
% ``C'', ``h'', ``A'', ``l''
\setlength{\tabcolsep}{3pt}
\begin{tabular}{ll|ll|ll}
$(\mathit{id}_1, \isa{InsertAfter } \mathit{id}_0, \text{``A''})$ & $\rightarrow$ \texttt{A} &
$(\mathit{id}_1, \isa{InsertAfter } \mathit{id}_0, \text{``A''})$ & $\rightarrow$ \texttt{A} &
$(\mathit{id}_1, \isa{InsertAfter } \mathit{id}_0, \text{``A''})$ & $\rightarrow$ \texttt{A} \\
%%%%%%%%%%
$(\mathit{id}_2, \isa{InsertAfter } \mathit{id}_1, \text{``l''})$ & $\rightarrow$ \texttt{Al} &
$(\mathit{id}_2, \isa{InsertAfter } \mathit{id}_0, \text{``C''})$ & $\rightarrow$ \texttt{CA} &
$(\mathit{id}_2, \isa{InsertAfter } \mathit{id}_0, \text{``C''})$ & $\rightarrow$ \texttt{CA} \\
%%%%%%%%%%
$(\mathit{id}_3, \isa{InsertAfter } \mathit{id}_0, \text{``C''})$ & $\rightarrow$ \texttt{CAl} &
$(\mathit{id}_3, \isa{InsertAfter } \mathit{id}_1, \text{``l''})$ & $\rightarrow$ \texttt{CAl} &
$(\mathit{id}_3, \isa{InsertAfter } \mathit{id}_2, \text{``h''})$ & $\rightarrow$ \texttt{ChA} \\
%%%%%%%%%%
$(\mathit{id}_4, \isa{InsertAfter } \mathit{id}_3, \text{``h''})$ & $\rightarrow$ \texttt{ChAl} &
$(\mathit{id}_4, \isa{InsertAfter } \mathit{id}_2, \text{``h''})$ & $\rightarrow$ \texttt{ChAl} &
$(\mathit{id}_4, \isa{InsertAfter } \mathit{id}_1, \text{``l''})$ & $\rightarrow$ \texttt{ChAl} \\[6pt] \hline &&&&&\\[-6pt]
%%%%%%%%%%
$(\mathit{id}_1, \isa{InsertAfter } \mathit{id}_0, \text{``C''})$ & $\rightarrow$ \texttt{C} &
$(\mathit{id}_1, \isa{InsertAfter } \mathit{id}_0, \text{``C''})$ & $\rightarrow$ \texttt{C} &
$(\mathit{id}_1, \isa{InsertAfter } \mathit{id}_0, \text{``C''})$ & $\rightarrow$ \texttt{C} \\
%%%%%%%%%%
$(\mathit{id}_2, \isa{InsertAfter } \mathit{id}_0, \text{``A''})$ & $\rightarrow$ \texttt{AC} &
$(\mathit{id}_2, \isa{InsertAfter } \mathit{id}_0, \text{``A''})$ & $\rightarrow$ \texttt{AC} &
$(\mathit{id}_2, \isa{InsertAfter } \mathit{id}_1, \text{``h''})$ & $\rightarrow$ \texttt{Ch} \\
%%%%%%%%%%
$(\mathit{id}_3, \isa{InsertAfter } \mathit{id}_2, \text{``l''})$ & $\rightarrow$ \texttt{AlC} &
$(\mathit{id}_3, \isa{InsertAfter } \mathit{id}_1, \text{``h''})$ & $\rightarrow$ \texttt{ACh} &
$(\mathit{id}_3, \isa{InsertAfter } \mathit{id}_0, \text{``A''})$ & $\rightarrow$ \texttt{ACh} \\
%%%%%%%%%%
$(\mathit{id}_4, \isa{InsertAfter } \mathit{id}_1, \text{``h''})$ & $\rightarrow$ \texttt{AlCh} &
$(\mathit{id}_4, \isa{InsertAfter } \mathit{id}_2, \text{``l''})$ & $\rightarrow$ \texttt{AlCh} &
$(\mathit{id}_4, \isa{InsertAfter } \mathit{id}_3, \text{``l''})$ & $\rightarrow$ \texttt{AlCh} \\
\end{tabular}
\caption{All possible operation orderings when ``Al'' (for ``Alice'') and ``Ch'' (for ``Charlie'') are concurrently inserted.
The IDs are arbitrary; we only require $id_0 < id_1 < id_2 < id_3 < id_4$.}\label{fig:op-permutations}
\end{figure}

\subsection{Comparison with Earlier Specifications}

We are aware of only one other formal specification of a collaboratively editable list datatype, which is due to Attiya et al.~\cite{Attiya:2016kh}
This specification is as follows:
\begin{displayquote}
An abstract execution $A = (H, \textsf{vis})$ belongs to the \emph{strong list specification} $\mathcal{A}_\textsf{strong}$ if and only if there is a relation $\textsf{lo} \subseteq \textsf{elems}(A) \times \textsf{elems}(A)$, called the \emph{list order}, such that:
\begin{enumerate}
\item Each event $e = \mathit{do}(\mathit{op}, w) \in H$ returns a sequence of elements $w=a_0 \dots a_{n-1}$, where $a_i \in \textsf{elems}(A)$, such that
\begin{enumerate}
\item $w$ contains exactly the elements visible to $e$ that have been inserted, but not deleted:
\[ \forall a.\; a \in w \quad\Longleftrightarrow\quad (\mathit{do}(\textsf{ins}(a, \_), \_) \le_\textsf{vis} e)
\;\wedge\; \neg(\mathit{do}(\textsf{del}(a), \_) \le_\textsf{vis} e). \]
\item The order of the elements is consistent with the list order:
\[ \forall i, j.\; (i < j) \;\Longrightarrow\; (a_i, a_j) \in \textsf{lo}. \]
\item Elements are inserted at the specified position:
if $\mathit{op} = \textsf{ins}(a, k)$, then $a = a_{\mathrm{min} \{k,\; n-1\}}$.
\end{enumerate}
\item The list order $\textsf{lo}$ is transitive, irreflexive and total, and thus determines the order of all insert operations in the execution.
\end{enumerate}
\end{displayquote}

The expression $\mathit{do}(\mathit{op}, w)$ denotes an operation that is performed by a user on one of the replicas.
While our specification is based on operations being replicated into other nodes' OpSets, Attiya et al.'s specification instead uses a visibility relation $\le_\textsf{vis}$.

We formalised the above specification in Isabelle/HOL, and prove formally that our specification is strictly stronger.
That is, every algorithm that satisfies our specification is guaranteed to also satisfy Attiya et al.'s specification.
However, there are also algorithms that satisfy Attiya et al.'s specification but not ours.
This is because Attiya et al.\ allow the interleaving behavior shown in Figure~\ref{fig:bad-merge}, whereas our specification does not allow it.

TODO more detail\dots
