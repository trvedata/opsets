\documentclass[11pt]{article}
\usepackage[a4paper,margin=2cm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage{mathptmx} % times roman, including math
\usepackage[hyphens]{url}
\usepackage{doi}
\usepackage{hyperref}
\usepackage[numbers,sort]{natbib}
\usepackage{amsmath}
\usepackage{setspace}
\usepackage{tikz}
\usetikzlibrary{arrows.meta}
\hyphenation{da-ta-cen-ter da-ta-cen-ters time-stamp time-stamps time-stamped Grish-chen-ko}
\frenchspacing

\begin{document}
\sloppy
\title{OpSets: Concurrent Datatypes with Sequential Specifications}
%\title{OpSets: Sequential Specifications for Concurrent Editing}
\author{}
\date{}
\maketitle

\subsection*{Abstract}
TODO

\section{Introduction}

A common requirement across a great variety of systems is that several participants may concurrently access and manipulate some shared data structure.
However, unconstrained concurrent manipulation may introduce inconsistencies that applications cannot tolerate.
Thus, various approaches for providing \emph{consistency guarantees} have been developed, ensuring that the data structure continues to obey certain invariants or semantics under concurrent access. For example:

\begin{description}
\item[Transaction isolation] in databases restricts the degree to which concurrently executing transactions can affect each other while accessing the same database.
The strongest isolation level, \emph{serializability}, ensures that transactions behave as if there were no concurrency at all, i.e.\ as if transactions were executed serially, one at a time.

\item[Conflict-free Replicated Data Types (CRDTs)] allow each participant to modify a local copy (\emph{replica}) of a shared data structure without waiting for communication with other replicas.
This has the consequence that the state of replicas may temporarily diverge, but the definition of CRDTs ensures that all replicas eventually converge towards a consistent state.

\item[Operational Transformation (OT)] algorithms are designed for several users who are concurrently editing a shared document, as implemented for example in Google Docs.
As with CRDTs, OT allows each user's changes to be applied immediately to their local copy, while ensuring that other users' concurrent edits can be integrated in a consistent way.
\end{description}

We discuss these techniques in more detail in Section~\ref{sec:relwork}.
Despite decades of research in the above topics, consistency mechanisms for concurrent data access remain poorly understood, and tools for reasoning about them (both formally and informally) are subtle and error-prone.
As we show in the following sections, many published algorithms exhibit serious anomalies, or even fail to ensure convergence of replicas, leaving the system in a permanently inconsistent state.

In this work we introduce \emph{Operation Sets} (or \emph{OpSets} for short), a novel approach for describing and reasoning about algorithms for concurrent data access and manipulation.
We go beyond merely ensuring replica convergence, and show how this approach simplifies the tasks of specifying and verifying more complex correctness properties.

Our contributions in this paper are as follows:

\begin{itemize}
\item We introduce the OpSet, a new abstraction for specifying and reasoning about the consistency properties of concurrently editable data structures.
On top of this abstraction, we specify a variety of abstract datatypes (maps, lists, trees, and registers), and we demonstrate that our specification is both simpler and more precise than previous efforts to specify the semantics of these data structures.

\item We demonstrate that our datatype specification captures an important correctness property that has been overlooked by prior work in this area.
Using our specification we review a selection of algorithms from the literature, and identify those that satisfy this correctness property.

\item Using the Isabelle/HOL proof assistant, we formally verify the consistency of our semantics with alternative approaches, and prove that selected algorithms satisfy the semantics.
By using mechanised proofs we eliminate the ambiguity of previous informal approaches, and we can rule out reasoning errors that could occur in handwritten proofs.
\end{itemize}

% Uniform representation; easier to add new operation types

% Constrain operation: not allowed to have a return value. For example, CAS

\input{approach}
\input{list}
\input{assign}
\input{relwork}

{\footnotesize
\bibliographystyle{plainnat}
\bibliography{references}{}}
\end{document}
