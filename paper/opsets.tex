\documentclass[11pt]{article}

\usepackage{authblk}
\usepackage[a4paper,margin=2cm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage{mathptmx} % times roman, including math
\usepackage[hyphens]{url}
\usepackage{doi}
\usepackage{hyperref}
\usepackage[numbers,sort]{natbib}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{stmaryrd} % \llbracket etc.
\usepackage{algorithm}
\usepackage{algpseudocode} % layout for algorithmicx package, provides "algorithmic" environment for pseudocode
\usepackage{setspace}
\usepackage{csquotes}
\usepackage{tikz}
\usetikzlibrary{arrows.meta}
\hyphenation{da-ta-cen-ter da-ta-cen-ters time-stamp time-stamps time-stamped Grish-chen-ko}
\frenchspacing

\newtheorem{proposition}{Proposition}

\begin{document}
\sloppy
\title{OpSets: Concurrent Datatypes with Sequential Specifications}
%\title{OpSets: Sequential Specifications for Concurrent Editing}
\author[1]{Martin Kleppmann\thanks{Corresponding author. Email: martin.kleppmann@cl.cam.ac.uk}}
\author[1]{Victor B.\ F.\ Gomes}
\author[2]{Dominic P.\ Mulligan}
\author[1]{Alastair R.\ Beresford}
\date{}

\affil[1]{Department of Computer Science and Technology, University of Cambridge, UK}
\affil[2]{Security Research Group, Arm Research, Cambridge, UK}

\maketitle

\begin{center}
Regular Paper
\end{center}

\begin{abstract}
This paper introduces OpSets, a new framework for specifying and reasoning about the semantics of replicated datatypes that provide eventual consistency in a distributed system.
First, we show our approach is simpler than previous work by using OpSets to succinctly specify a variety of abstract data types, including maps, sets, lists, text, graphs, trees, and registers.
Our data types are also composable, enabling the construction of complex data structures such as a list of maps.
We then demonstrate the utility of OpSets as a tool to support the analysis of existing algorithms for eventual consistency.
In particular, we highlight an important new correctness property in collaborative text editing.
This property has traditionally been overlooked and can result in awkward interleaving of text, and we use OpSets to specify the required correctness property and prove that one existing algorithm supports this property while other published algorithms do not. 
Finally, we also show how OpSets can be used to make improvements in the state-of-the-art, by providing a simple specification of an atomic move operation for complex abstract datatypes, something which had previously been thought impossible without locking.
We use the Isabelle/HOL proof assistant throughout to formalise the OpSets approach and produce mechanised proofs of correctness of the main claims in this paper, thereby eliminating the ambiguity of previous informal approaches and ruling out reasoning errors that could occur in handwritten proofs.
\end{abstract}
\clearpage

\section{Introduction}

A common requirement across a great variety of systems is that several participants may concurrently access and manipulate some shared data structure, such as a text document, a spreadsheet, or a database.
In doing so, it is important that the shared data satisfies certain \emph{consistency guarantees}.
For example, strong consistency models such as serializability \cite{Kleppmann:2017wj} or linearizability \cite{Herlihy:1990jq} attempt to make a system behave like a single sequentially executing node, even when it is in fact replicated and concurrent.
An unavoidable downside of these models is that they require waiting for synchronous network communication before any operation or transaction is allowed to complete \cite{Davidson:1985hv,Gilbert:2002il}.
Thus, in a system with strong consistency, a node cannot make progress while it is offline or partitioned from other nodes.

On the other hand, \emph{eventual consistency} \cite{Bailis:2013jc,Burckhardt:2014hy,Terry:1994fp,Vogels:2009ca} allows each participant to modify a local copy (\emph{replica}) of a shared data structure while offline, but its definition is very weak: \emph{``if no new updates are made to the shared state, all nodes will eventually have the same data.''}
The premise \emph{if no new updates are made} may never be true, for example if the shared state is continually modified because the system is never quiescent.
Moreover, the final state that is eventually reached is unconstrained: nothing in the definition of eventual consistency specifies which states are legal.

Conflict-free Replicated Data Types, or CRDTs \cite{Shapiro:2011wy,Shapiro:2011un}, are abstractions for replicated state that have received significant attention in recent years (see Section~\ref{sec:relwork}).
The primary correctness property for CRDTs is \emph{convergence} \cite{Shapiro:2011un,Gomes:2017gy}, defined as: \emph{``whenever any two replicas have applied the same set of updates, they are in the same state''} (even if each replica applies the updates in a different order).
Convergence is a stronger property than eventual consistency, but it also fails to define what the converged state should be.

In this work we introduce \emph{Operation Sets} (or \emph{OpSets} for short), a novel approach for specifying the semantics of replicated datatypes, and reasoning about algorithms for concurrent data access and manipulation.
We go beyond merely ensuring replica convergence: the OpSets approach is a form of executable specification that precisely defines the permitted states of a replica after some set of updates has been applied.

Our contributions in this paper are as follows:

\begin{itemize}
\item In Section~\ref{sec:approach} we introduce the OpSet, a new abstraction for specifying and reasoning about the consistency properties of concurrently editable data structures.
On top of this abstraction, we specify a variety of abstract datatypes (maps, sets, lists, text, graphs, trees, and registers) in Sections~\ref{sec:datatypes} and~\ref{sec:tree}, and we argue that our specification is both simpler and more precise than previous efforts to specify the semantics of these data structures.

\item In Section~\ref{sec:bad-merge} we highlight an important correctness property for collaborative text editing that has been overlooked by prior work in this area.
Our specification is, to our knowledge, the first that correctly captures this property.
We then review a selection of text editing CRDTs from the literature, prove that one satisfies our specification, and identify several others that fail to satisfy our correctness property.

\item In Section~\ref{sec:tree} we demonstrate, for the first time, how an atomic move operation can be defined for a tree CRDT.
This operation can be used to move a subtree to a new position within the tree, or to rename a key in a map, or to reorder items in a list.
The OpSets approach enables a simple definition of this operation that had previously been thought to be impossible without locking \cite{Najafzadeh:2017vk}.

\item Using the Isabelle/HOL proof assistant~\cite{DBLP:conf/tphol/WenzelPN08} we formalise the OpSets approach, producing mechanised proofs of correctness of the main claims in this paper.
In particular, we prove that our list specification is strictly stronger than the recent specification of collaborative text editing by Attiya et al. \cite{Attiya:2016kh}, and we prove that our tree specification satisfies the required invariants.
By using mechanised proofs we eliminate the ambiguity of previous informal approaches, and rule out reasoning errors that could occur in handwritten proofs.
\end{itemize}

\input{approach}
\input{datatypes}
\input{textedit}
\input{tree}
\input{relwork}

\section{Conclusion}

TODO

\bibliographystyle{plainnat}
\bibliography{references}{}
\end{document}
