\documentclass[11pt]{article}

\usepackage{authblk}
\usepackage[a4paper,margin=1.8cm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage{mathptmx} % times roman, including math
\usepackage[hyphens]{url}
\usepackage{doi}
\usepackage{hyperref}
\usepackage[numbers,sort]{natbib}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{stmaryrd} % \llbracket etc.
\usepackage{algorithm}
\usepackage{algpseudocode} % layout for algorithmicx package, provides "algorithmic" environment for pseudocode
\usepackage{setspace}
\usepackage{csquotes}
\usepackage{tikz}
\usepackage{mdwlist}
\usepackage{setspace}
\usepackage{calc}
\usepackage{paralist}

\usetikzlibrary{arrows.meta}
\hyphenation{da-ta-cen-ter da-ta-cen-ters time-stamp time-stamps time-stamped Grish-chen-ko}
\frenchspacing

\usepackage{isabelle,isabellesym}
\isabellestyle{it}

\newtheorem{proposition}{Proposition}

\begin{document}
\sloppy
\title{OpSets: Sequential Specifications for Replicated Datatypes}
\author[1]{Martin Kleppmann\thanks{Corresponding author. Email: martin.kleppmann@cl.cam.ac.uk}}
\author[1]{Victor B.\ F.\ Gomes}
\author[2]{Dominic P.\ Mulligan}
\author[1]{Alastair R.\ Beresford}
\date{}

\affil[1]{Department of Computer Science and Technology, University of Cambridge, UK}
\affil[2]{Security Research Group, Arm Research, Cambridge, UK}

\maketitle

\begin{center}
Regular Paper (not eligible for best student paper award)
\end{center}

\begin{abstract}
We introduce OpSets, a framework for specifying and reasoning about the semantics of replicated datatypes that provide eventual consistency in a distributed system, and for formally verifying algorithms that implement these datatypes.
Our approach is simple but expressive, allowing us to succinctly specify a variety of abstract datatypes, including maps, sets, lists, text, graphs, trees, and registers.
Our datatypes are also composable, enabling the construction of complex data structures.
To demonstrate the utility of OpSets for analysing replication algorithms, we highlight an important correctness property for collaborative text editing that has traditionally been overlooked; algorithms that do not satisfy this property can exhibit awkward interleaving of text.
We use OpSets to specify this correctness property and prove that although one existing replication algorithm satisfies this property, several other published algorithms do not.
We also show how OpSets can be used to develop new replicated datatypes: we provide a simple specification of an atomic move operation for trees, an operation that had previously been thought to be impossible to implement without locking.
We use the Isabelle/HOL proof assistant throughout to formalise the OpSets approach and produce mechanised proofs of correctness of the main claims in this paper, thereby eliminating the ambiguity of previous informal approaches, and ruling out reasoning errors that could occur in handwritten proofs.
\end{abstract}
\clearpage

\section{Introduction}

A common requirement across many distributed systems is that several nodes may concurrently access and manipulate some shared data structure.
Examples include everything from journalists using their laptops to work on a shared text document to a set of front-end web-servers manipulating a common database.
In doing so, it is important that the shared data satisfies certain \emph{consistency guarantees}.
For example, strong consistency models such as serializability \cite{Kleppmann:2017wj} or linearizability \cite{Herlihy:1990jq} make a system behave like a single sequentially executing node, even when it is in fact replicated and concurrent.
An unavoidable downside of these models is that any operation or transaction must wait for network communication before it is allowed to complete \cite{Davidson:1985hv,Gilbert:2002il}.
Thus, in a system with strong consistency, a node cannot make progress while it is offline or partitioned from other nodes.

On the other hand, \emph{eventual consistency} \cite{Bailis:2013jc,Burckhardt:2014hy,Terry:1994fp,Vogels:2009ca} allows each participant to modify a local copy (\emph{replica}) of a shared data structure while offline, but its definition is very weak: \emph{``if no new updates are made to the shared state, all nodes will eventually have the same data.''}
The premise \emph{if no new updates are made} may never be true if the shared state is continually modified because the system is never quiescent.
Moreover, the final system state is unconstrained: nothing in the definition of eventual consistency specifies which states are legal.

Conflict-free Replicated Data Types, or CRDTs \cite{Shapiro:2011wy,Shapiro:2011un}, are abstractions for replicated state that have received significant attention in recent years (see \S~\ref{sec:relwork}).
The primary correctness property for CRDTs is \emph{convergence} \cite{Shapiro:2011un,Gomes:2017gy}, defined as: \emph{``whenever any two replicas have applied the same set of updates, they are in the same state''}, even if each replica applies the updates in a different order.
Convergence is a stronger property than eventual consistency, but it also fails to define what the converged state should be.

In this work we introduce \emph{Operation Sets} (or \emph{OpSets} for short), a novel approach for specifying the semantics of replicated datatypes, and for reasoning about algorithms for concurrent data access and manipulation.
We go beyond merely ensuring replica convergence: the OpSets approach is a form of executable specification that precisely defines the permitted states of a replica after some set of updates has been applied.
Our contributions in this paper are as follows:

\begin{itemize*}
\item In \S~\ref{sec:approach} we introduce the OpSet, a new abstraction for specifying and reasoning about the consistency properties of concurrently editable data structures.

\item On top of this abstraction, in \S~\ref{sec:datatypes} and \S~\ref{sec:tree}, we specify a variety of composable abstract datatypes (maps, sets, lists, text, graphs, trees, and registers), and we argue that our specifications are both simple and precise, making them a suitable tool for reasoning about replicated data.

\item In \S~\ref{sec:bad-merge} we demonstrate how the OpSet abstraction can be used to reason about existing algorithms. We highlight an important correctness property for collaborative text editing that has been overlooked by prior work in this area.
Our specification is, to our knowledge, the first that correctly captures this property.
We then review a selection of text editing CRDTs from the literature, prove that one satisfies our specification, and identify several others that fail to satisfy our correctness property.

\item In \S~\ref{sec:tree} we show how the OpSet abstraction can be used to develop new replicated datatypes. In particular we describe, for the first time, how an atomic move operation can be defined for a tree CRDT.
This operation can be used to move a subtree to a new position within the tree, or to rename a key in a map, or to reorder items in a list.
The OpSets approach enables a simple definition of this operation that had previously been thought impossible without locking \cite{Najafzadeh:2017vk}.

\item Using the Isabelle/HOL proof assistant~\cite{DBLP:conf/tphol/WenzelPN08} we formalise the OpSets approach, producing mechanised proofs of correctness of the main claims in this paper.
In particular, we prove that our list specification is strictly stronger than the recent specification of collaborative text editing by Attiya et al. \cite{Attiya:2016kh}.
By using mechanised proofs we eliminate the ambiguity of previous informal approaches, and rule out reasoning errors that could occur in handwritten proofs.
Moreover, the proof framework we have developed is reusable and can be leveraged to verify other datatypes in the future.
\end{itemize*}

\input{approach}
\input{datatypes}
\input{textedit}
\input{tree}
\input{relwork}

\section{Conclusion}

In this work we have introduced Operation Sets (OpSets), a simple but expressive approach for specifying the semantics of replicated datatypes.
We specified a variety of common, composable replicated datatypes in the OpSets model, and used Isabelle/HOL to formally reason about their properties.
We have also shown how the OpSet abstraction can be used to reason about existing replication algorithms, and developed a new specification to highlight an interleaving anomaly that affects some existing collaborative text editing algorithms.
Finally we demonstrated how the OpSet model to can be used to develop new specifications to support algorithm design, and developed a specification for an atomic move operation in a tree CRDT.

The OpSets approach is a form of executable specification that precisely defines the permitted states of a replica after some set of updates have been applied.
The simplicity of our approach builds on sequential OpSet interpretation: operations are applied in strict ascending order of ID.
This property is very useful as it trivially ensures convergence, and it simplifies reasoning about specifications and invariants for CRDTs.
In contrast, the traditional approach requires operations to be defined in a way that is commutative, increasing their complexity.
We took advantage of the ease of specification to demonstrate the correspondence between sequential specification and commutative implementation, proving that the RGA CRDT satisfies our OpSet specification of lists.
For future work it will be interesting to further explore this correspondence for other datatypes; in particular, we hypothesise that it is possible to derive a tree CRDT with a commutative move operation from the specification in \S~\ref{sec:tree}.

%More generally, one can regard the OpSet as a \emph{database of facts}, containing all changes ever made to the shared data, and the interpretation function a \emph{query} over this database, with the resulting datatype being a \emph{materialized view} in database terminology.
%When new operations are added to an OpSet $O$, computing the corresponding change to $\llbracket O \rrbracket$ is a \emph{materialized view maintenance} problem, which has been studied extensively in the database literature \cite{Gupta:1999uz}.
%We have found that thinking about replicated datatypes as materialized views onto an OpSet a useful perspective for understanding and improving replication algorithms, and in future work we aim to explore this idea more fully.

\subsection*{Acknowledgements}

The authors wish to acknowledge the support of The Boeing Company,
the EPSRC ``REMS: Rigorous Engineering for Mainstream Systems'' programme grant (EP/K008528), and
the EPSRC ``Interdisciplinary Centre for Finding, Understanding and Countering Crime in the Cloud'' grant (EP/M020320).
We thank Nathan Chong, Peter Sewell, and KC Sivaramakrishnan for their helpful feedback on this paper.

\newpage

\bibliographystyle{plainnat}
\bibliography{references}{}

\newpage

\appendix

\section{Introduction to Isabelle/HOL}
\label{sect:appendix:isabelle}

In the following appendices we provide a copy of the Isabelle/HOL definitions and proof statements that support the central claims in the paper.
To help any readers who are not familiar with Isabelle/HOL, we first provide a brief introduction to the key concepts and syntax, taken from our previous work \cite{Gomes:2017gy}.
A more detailed introduction can be found in the standard tutorial material~\cite{DBLP:books/sp/NipkowK14}.

\paragraph{Syntax of expressions.}

Isabelle/HOL is a logic with a strict, polymorphic, inferred type system.
\emph{Function types} are written $\tau_1 \Rightarrow \tau_2$, and are inhabited by \emph{total} functions, mapping elements of $\tau_1$ to elements of $\tau_2$.
We write $\tau_1 \times \tau_2$ for the \emph{product type} of $\tau_1$ and $\tau_2$, inhabited by pairs of elements of type $\tau_1$ and $\tau_2$, respectively.
\emph{Type operators} are applied to arguments in reverse order: $\tau\ \isa{list}$ denotes the type of lists of elements of type $\tau$, and $\tau\ \isa{set}$ denotes the type of mathematical (i.e., potentially infinite) sets of type $\tau$, for instance.
Type variables are written in lowercase, and preceded with a prime: ${\isacharprime}a \Rightarrow {\isacharprime}a$ denotes the type of a polymorphic identity function, for example.
\emph{Tagged union} types are introduced with the $\isacommand{datatype}$ keyword, with \emph{constructors} of these types usually written with an initial upper case letter.

In Isabelle/HOL's term language we write $\isa{t} \mathbin{::} \tau$ for a \emph{type ascription}, constraining the type of the term $\isa{t}$ to the type $\tau$.
We write $\lambda{x}.\: t$ for an anonymous function mapping an argument $\isa{x}$ to $\isa{t(x)}$, and write the application of term $\isa{t}$ with function type to an argument $\isa{u}$ as $\isa{t\ u}$.
Terms of list type are introduced using one of two constructors: the empty list $[\,]$ or `nil', and the infix operator $\isa{\#}$ which is pronounced ``cons'', and which prepends an element to an existing list.
We use $[t_1, \ldots, t_n]$ as syntactic sugar for a list literal, and $\isa{xs} \mathbin{\isacharat} \isa{ys}$ to express the concatenation (appending) of two lists $\isa{xs}$ and $\isa{ys}$.
We write $\{\,\}$ for the empty set, and use usual mathematical notation for set union, disjunction, membership tests, and so on: $\isa{t} \cup \isa{u}$, $\isa{t} \cap \isa{u}$, and $\isa{x} \in \isa{t}$.
We write $t \longrightarrow s$ for logical implication between formulae (terms of type $\isa{bool}$).
Strictly speaking Isabelle is a logical framework, providing a weak meta-logic within which object logics are embedded, including the Isabelle/HOL object logic that we use in this work.
Accordingly, the implication arrow of Isabelle's meta-logic, $\isa{t} \Longrightarrow \isa{u}$, is required in certain contexts over the object-logic implication arrow, $t \longrightarrow s$, already introduced.
However, for purposes of an intuitive understanding, the two forms of implication can be regarded as equivalent by the reader, with the requirement to use one over the other merely being an implementation detail of Isabelle itself.
We will sometimes use the shorthand ${\isasymlbrakk}\isa{H}_1{\isacharsemicolon}\ \ldots{\isacharsemicolon}\ \isa{H}_n{\isasymrbrakk}\ {\isasymLongrightarrow}\ C$ instead of iterated meta-logic implications, i.e., $H_1\ {\isasymLongrightarrow}\ \ldots\ {\isasymLongrightarrow}\ H_n\ {\isasymLongrightarrow}\ C$.

\paragraph{Definitions and theorems.}

New non-recursive definitions are entered into Isabelle's global context using the $\mathbf{definition}$ keyword.
Recursive functions are defined using the $\mathbf{fun}$ keyword, and support \emph{pattern matching} on their arguments.
All functions are total, and therefore every recursive function must be provably terminating.
All termination proofs in this work are generated automatically by Isabelle itself.

\emph{Inductive relations} are defined with the $\mathbf{inductive}$ keyword.
For example, the definition
\begin{isabelle}
\isacommand{inductive} only-fives\ {\isacharcolon}{\isacharcolon}\ {\isachardoublequoteopen}nat\ list\ {\isasymRightarrow}\ bool{\isachardoublequoteclose}\ \isakeyword{where} \\
~~~~{\isachardoublequoteopen}only-fives\ {\isacharbrackleft}{\isacharbrackright}{\isachardoublequoteclose}\ {\isacharbar}\\
~~~~{\isachardoublequoteopen}{\isasymlbrakk}\ only-fives\ xs\ {\isasymrbrakk}\ {\isasymLongrightarrow}\ only-fives {\isacharparenleft}5\#xs{\isacharparenright}{\isachardoublequoteclose}
\end{isabelle}
\noindent %dpm: spacing above
introduces a new constant $\isa{only-fives}$ of type $\isa{nat list} \Rightarrow \isa{bool}$.
The two clauses in the body of the definition enumerate the conditions under which $\isa{only-fives}\ \isa{xs}$ is true, for arbitrary $\isa{xs}$: firstly, $\isa{only-fives}$ is true for the empty list; and secondly, if you know that $\isa{only-fives}\ \isa{xs}$ is true for some $\isa{xs}$, then you can deduce that $\isa{only-fives}\ (5\#\isa{xs})$ (i.e., $\isa{xs}$ prefixed with the number 5) is also true.
Moreover, $\isa{only-fives}\ \isa{xs}$ is true in no other circumstances---it is the \emph{smallest} relation closed under the rules defining it.
In short, the clauses above state that $\isa{only-fives}\ \isa{xs}$ holds exactly in the case where $\isa{xs}$ is a (potentially empty) list containing only repeated copies of the natural number $5$.

Lemmas, theorems, and corollaries can be asserted using the $\isacommand{lemma}$, $\isacommand{theorem}$, and $\isacommand{corollary}$ keywords, respectively.
There is no semantic difference between these keywords in Isabelle.
For example,
\begin{isabelle}
\isacommand{theorem} only-fives-concat{\isacharcolon} \\
~~~~\isakeyword{assumes}\ only-fives\ xs \isakeyword{and}\ only-fives\ ys\\
~~~~\isakeyword{shows}\ only-fives\ (xs \isacharat ys)
\end{isabelle}
\noindent %dpm: spacing above
conjectures that if $\isa{xs}$ and $\isa{ys}$ are both lists of fives, then their concatenation $xs \mathbin{\isacharat} ys$ is also a list of fives.
Isabelle then requires that this claim be proved by using one of its proof methods, for example by induction.
Some proofs can be automated, whilst others require the user to provide explicit reasoning steps.
The theorem is assigned a name, here $\isa{only-fives-concat}$, so that it may be referenced in later proofs.

\newpage

\isafoldtag{proof}
\input{../isabelle/output/outline/OpSet}
\input{../isabelle/output/outline/Insert_Spec}
\input{../isabelle/output/outline/Interleaving}
\input{../isabelle/output/outline/RGA}

\end{document}
