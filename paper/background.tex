\section{Background}\label{sec:background}

At a high level, consistency models for distributed data systems can be classified into two categories:
\begin{description}
\item[Strong consistency models] such as serialisability or linearisability \cite{Herlihy:1990jq} attempt to make a system behave like a single sequentially executing node, even when it is in fact replicated and concurrent.
An unavoidable downside of these models is that they require waiting for synchronous network communication before any operation or transaction is allowed to complete \cite{Davidson:1985hv,Gilbert:2002il}.
Thus, a node cannot make progress while it is offline or partitioned from other nodes.
In a formal sense, enforcing a strong consistency model is equivalent to consensus \cite{Chandra:1996cp,Herlihy:1991gk}, which implies that the algorithm cannot be guaranteed to terminate in an asynchronous system \cite{Fischer:1985tt}.

\item[Weak consistency models] are employed by systems that prioritise availability over strong consistency; for example, systems that require nodes to be able to make progress while offline or while partitioned from other nodes.
In such systems, each node typically reads and manipulates a local copy of the shared state, and propagates any changes to that state asynchronously to other nodes.
Examples of weak consistency models in this category are \emph{causal consistency} \cite{Attiya:2015dm,Mahajan:2011wz,Lloyd:2011hz} and \emph{eventual consistency} \cite{Bailis:2013jc,Burckhardt:2014hy,Terry:1994fp,Vogels:2009ca}.
\end{description}

In this work we focus on the latter category of weak consistency models.
However, as we shall demonstrate shortly, the OpSets approach allows us to specify our consistency model more precisely than existing techiques permit.

\subsection{Eventual Consistency is Insufficient}\label{sec:eventual-consistency}

Eventual consistency is usually informally defined as follows: \emph{if no new updates are made to the shared state, all nodes will eventually have the same data}.
This is a very weak definition for several reasons:
\begin{itemize}
\item The premise, \emph{if no new updates are made}, may never be true (if the shared state is continually modified because the system is never quiescent).
In that case, eventual consistency becomes a vacuous statement.

\item Many trivial algorithms satisfy the requirement of converging towards the same state.
For example, a system could simply discard writes, and thus converge to a state in which operations have been ignored.
Although such a system would not be useful in practice, the definition of eventual consistency does not capture the requirement that writes should be persistent.

\item In a system that allows nodes to make progress while they are partitioned from other nodes, it is inevitable that the local state of individual nodes might diverge due to concurrent modifications.
Such divergent states must then be merged at a later time, when communication between the nodes is restored.
Even if we require that this merge operation does not discard data that has been written, eventual consistency does not specify which states should be considered valid results of the merge operation.
We show in Section~\ref{sec:bad-merge} how such under-specification can lead to undesirable outcomes.
\end{itemize}

\subsection{Example: Merging Text Edits}\label{sec:bad-merge}

To demonstrate a problem with an under-specified consistency model, consider the example in Figure~\ref{fig:bad-merge}.
In this example, two users are concurrently editing a text document that initially reads ``Hello!''.
The user on the left changes it to read ``Hello Alice!'', while concurrently the user on the right changes the document to read ``Hello Charlie!''.
When the concurrent edits are merged, the algorithm randomly interleaves the two insertions of ``~Alice'' and ``~Charlie'' character by character, resulting in an unreadable jumble of characters.

\begin{figure}
\centering
\begin{tikzpicture}
  \tikzstyle{box}=[rectangle,draw,inner xsep=6pt,text height=9pt,text depth=2pt]
  \tikzstyle{every path}=[draw,-{Stealth[length=3.5mm]}]
  \node [box] (start) at (3,4) {\texttt{Hello!}};
  \node [box] (left)  at (0,2) {\texttt{Hello Alice!}};
  \node [box] (right) at (6,2) {\texttt{Hello Charlie!}};
  \node [box] (merge) at (3,0) {\texttt{Hello Al Ciharcliee!}};
  \draw (start) to node [left,inner xsep=10pt]  {Insert ``~Alice'' between ``o'' and ``!''} (left);
  \draw (start) to node [right,inner xsep=10pt] {Insert ``~Charlie'' between ``o'' and ``!''} (right);
  \draw (left)  -- (merge);
  \draw (right) -- (merge);
  \node [text width=3cm,text badly centered] at (3,1) {Merge concurrent edits};
\end{tikzpicture}
\caption{Two concurrent insertions at the same position are interleaved.}\label{fig:bad-merge}
\end{figure}

The problem is even worse if the concurrent insertions are not just a single word, but an entire paragraph or section.
In these cases, interleaving the users' insertions would most likely result in an entirely incomprehensible text that would have to be deleted and rewritten.

Even though the merge in Figure~\ref{fig:bad-merge} is so obviously undesirable, there is to our knowledge no formal specification of collaborative text editing that rules out such an interleaving of insertions.
For example, the recent formal specification of collaborative text editing by Attiya et al.~\cite{Attiya:2016kh} allows the outcome in Figure~\ref{fig:bad-merge}.
Paraphrased informally, Attiya et al.'s specification requires that all character insertions and deletions take effect (no input is lost), and that the relative ordering of all characters is preserved (in the merged result, ``A'' comes before ``l'', which comes before ``i'', which comes before ``c'', etc).
An interleaved result, as in Figure~\ref{fig:bad-merge}, satisfies both of these requirements.

Moreover, several published algorithms for collaborative text editing allow the anomaly shown in Figure~\ref{fig:bad-merge}, and to our knowledge this anomaly has not been previously discussed in the literature.
We discuss these algorithms further in Section~\ref{sec:relwork}.

Rather than interleaving characters, a better approach to merging is to keep all insertions by a particular user together as a continuous sequence.
With this constraint, there are two acceptable merged results in the example of Figure~\ref{fig:bad-merge}: either ``Hello Alice Charlie!'' or ``Hello Charlie Alice!''.
The choice between these two outcomes is arbitrary, as there is no a priori requirement for one user's insertions to come before another's.
In Section~\ref{sec:datatypes} we give a specification that incorporates this constraint.
