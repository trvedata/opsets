\documentclass[twocolumn,10pt]{article}
\usepackage[a4paper,margin=2cm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage{mathptmx} % times roman, including math
\usepackage[hyphens]{url}
\usepackage{doi}
\usepackage{hyperref}
\usepackage[numbers,sort]{natbib}
\usepackage{amsmath}
\hyphenation{da-ta-cen-ter da-ta-cen-ters}
\frenchspacing

\begin{document}
\sloppy
\title{OpSets}
\author{}
\date{}
\maketitle

\subsection*{Abstract}

\section{Introduction}

\cite{Attiya:2016kh}

% Topological orderings are also closely related to the concept of a linear
% extension of a partial order in mathematics.
% https://en.wikipedia.org/wiki/Topological_sorting

\begin{figure*}
\begin{align*}
    \mathrm{happensBefore}(\mathit{Op1}, \mathit{Op2}) \leftarrow\; &
    \mathrm{depends}(\mathit{Op1}, \mathit{Op2}).
\\
    \mathrm{happensBefore}(\mathit{Op1}, \mathit{Op2}) \leftarrow\; &
    \mathrm{depends}(\mathit{Op1}, \mathit{Op3}),
    \mathrm{happensBefore}(\mathit{Op3}, \mathit{Op2}).
\\
    \mathrm{concurrent}(\mathit{Op1}, \mathit{Op2}) \leftarrow\; &
    \mathrm{op}(\mathit{Op1}), \mathrm{op}(\mathit{Op2}),
    \neg\mathrm{happensBefore}(\mathit{Op1}, \mathit{Op2}),
    \neg\mathrm{happensBefore}(\mathit{Op2}, \mathit{Op1}).
\\
    & \text{TODO\dots this is not thought through yet}
\\
    \mathrm{applyOrder}(\mathit{Op1}, \mathit{Op2}) \leftarrow\; &
    \mathrm{happensBefore}(\mathit{Op1}, \mathit{Op2}).
\\
    \mathrm{happensNext}(\mathit{Op1}, \mathit{Op2}) \leftarrow\; &
    \mathrm{happensBefore}(\mathit{Op1}, \mathit{Op2}),
    \neg\mathrm{happensBefore}(\mathit{Op1}, \mathit{Op3}),
    \neg\mathrm{happensBefore}(\mathit{Op3}, \mathit{Op2}).
\\
    \mathrm{firstNext}(\mathit{Op1}, \mathit{Op2}) \leftarrow\; &
    \mathrm{happensNext}(\mathit{Op1}, \mathit{Op2}),
    \neg\mathrm{happensNext}(\mathit{Op1}, \mathit{Op3}), \mathit{Op3} < \mathit{Op2}.
\end{align*}
\caption{Causal ordering of operations.}
\end{figure*}

\begin{figure*}
\begin{align*}
    \mathrm{child}(\mathit{List}, \mathit{Parent}, \mathit{Child}) \leftarrow\; &
    \mathrm{insert}(\mathit{List}, \mathit{Parent}, \mathit{Child}, \mathit{Value}).
\\
    \mathrm{firstChild}(\mathit{List}, \mathit{Parent}, \mathit{Child}) \leftarrow\; &
    \mathrm{child}(\mathit{List}, \mathit{Parent}, \mathit{Child}),
    \neg\mathrm{child}(\mathit{List}, \mathit{Parent}, \mathit{Other}),
    \mathit{Child} < \mathit{Other}.
\\
    \mathrm{sibling}(\mathit{List}, \mathit{Child1}, \mathit{Child2}) \leftarrow\; &
    \mathrm{child}(\mathit{List}, \mathit{Parent}, \mathit{Child1}),
    \mathrm{child}(\mathit{List}, \mathit{Parent}, \mathit{Child2}).
\\
    \mathrm{nextSibling}(\mathit{List}, \mathit{Prev}, \mathit{Next}) \leftarrow\; &
    \mathrm{sibling}(\mathit{List}, \mathit{Prev}, \mathit{Next}),
    \mathit{Next} < \mathit{Prev},\\&
    \neg\mathrm{sibling}(\mathit{List}, \mathit{Prev}, \mathit{Other}),
    \mathit{Next} < \mathit{Other},
    \mathit{Other} < \mathit{Prev}.
\\
    \mathrm{siblinglessAncestor}(\mathit{List}, \mathit{Start}, \mathit{Start}) \leftarrow\; &
    \mathrm{insert}(\mathit{List}, \mathit{Parent}, \mathit{Start}, \mathit{Value}),
    \neg\mathrm{nextSibling}(\mathit{List}, \mathit{Start}, \mathit{Sibling}).
\\
    \mathrm{siblinglessAncestor}(\mathit{List}, \mathit{Start}, \mathit{Next}) \leftarrow\; &
    \mathrm{siblinglessAncestor}(\mathit{List}, \mathit{Start}, \mathit{Prev}),
    \mathrm{child}(\mathit{List}, \mathit{Next}, \mathit{Prev}), \\&
    \neg\mathrm{nextSibling}(\mathit{List}, \mathit{Next}, \mathit{Sibling}).
\\
    \mathrm{nextElem}(\mathit{List}, \mathit{Prev}, \mathit{Next}) \leftarrow\; &
    \mathrm{firstChild}(\mathit{List}, \mathit{Prev}, \mathit{Next}).
\\
    \mathrm{nextElem}(\mathit{List}, \mathit{Prev}, \mathit{Next}) \leftarrow\; &
    \neg\mathrm{firstChild}(\mathit{List}, \mathit{Prev}, \mathit{Child}),
    \mathrm{nextSibling}(\mathit{List}, \mathit{Prev}, \mathit{Next}).
\\
    \mathrm{nextElem}(\mathit{List}, \mathit{Prev}, \mathit{Next}) \leftarrow\; &
    \neg\mathrm{firstChild}(\mathit{List}, \mathit{Prev}, \mathit{Child}),
    \mathrm{siblinglessAncestor}(\mathit{List}, \mathit{Prev}, \mathit{Anc}), \\&
    \mathrm{child}(\mathit{List}, \mathit{Parent}, \mathit{Anc}),
    \mathrm{nextSibling}(\mathit{List}, \mathit{Parent}, \mathit{Next}).
\end{align*}
\caption{Datalog rules for an ordered list (insertion only).}
\end{figure*}

{\footnotesize
\bibliographystyle{plainnat}
\bibliography{references}{}}
\end{document}
